% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/sim_hier_mnl.R
\name{sim_hier_mnl}
\alias{sim_hier_mnl}
\title{Simulate Hierarchical Multinomial Logit Data}
\usage{
sim_hier_mnl(
  nlgt = 300,
  nT = 10,
  p = 3,
  nz = 5,
  nXa = 2,
  nXd = 1,
  const = TRUE,
  z_dist_func = function(n, d) matrix(stats::runif(n * d, -1, 1), n, d),
  standardize_Z = TRUE,
  beta_func_type = "linear",
  beta_func_args = list(),
  ncomp = 1,
  mixture_comps = NULL,
  sigma_inv_diag = 1,
  Xa_dist_func = function(n, p, na) matrix(stats::runif(n * p * na, -1, 1), ncol = p *
    na),
  Xd_dist_func = function(n, nd) matrix(stats::rnorm(n * nd), ncol = nd),
  seed = NULL
)
}
\arguments{
\item{nlgt}{Integer. Number of individuals or cross-sectional units.}

\item{nT}{Integer. Number of choice observations per individual.}

\item{p}{Integer. Number of choice alternatives (including outside option if any).}

\item{nz}{Integer. Number of demographic/individual-specific variables in Z.
If \code{nz = 0}, no Z matrix is generated, \code{betabar_true} is set to zero,
and \code{beta_func_type}/\code{beta_func_args} are ignored.}

\item{nXa}{Integer. Number of alternative-specific variables in X.}

\item{nXd}{Integer. Number of choice-invariant variables in X (e.g., price).}

\item{const}{Logical. Include p-1 intercepts in the model?}

\item{z_dist_func}{Function. A function to generate the Z matrix.
Must accept arguments \code{n} (nlgt) and \code{d} (nz) and return an n x d matrix.
Default: \code{function(n, d) matrix(runif(n*d, -1, 1), n, d)}.}

\item{standardize_Z}{Logical. Standardize the generated Z matrix (mean 0, sd 1)?}

\item{beta_func_type}{Character. Specifies the functional form mapping Z to
the systematic component of beta (\code{betabar_i}). Ignored if \code{nz = 0}.
Options:
\itemize{
\item \code{"linear"}: Linear function \code{betabar_i = Z_i \%*\% Delta}. Requires \code{Delta} in \code{beta_func_args}.
\item \code{"step"}: Step function based on one Z variable. Requires \code{cutoff}, \code{beta_1}, \code{beta_2}, \code{Z_index} in \code{beta_func_args}.
\item \code{"friedman"}: Friedman benchmark function (modified) based on first 5 Z variables. Requires \code{coef_index} in \code{beta_func_args} to specify which coefficient it applies to (others are zero).
\item \code{"custom"}: A user-defined function provided in \code{beta_func_args$func}.
}}

\item{beta_func_args}{List. Arguments needed for the chosen \code{beta_func_type}.
Ignored if \code{nz = 0}.
\itemize{
\item For \code{"linear"}: \code{list(Delta = matrix(runif(ncoef * nz), nrow=nz))}. Delta is \verb{nz x ncoef}.
\item For \code{"step"}: \code{list(cutoff = 0, beta_1 = rep(-1, ncoef), beta_2 = rep(1, ncoef), Z_index = 1)}. \code{beta_1}/\code{beta_2} are vectors of length \code{ncoef}. \code{Z_index} is the column of Z to use.
\item For \code{"friedman"}: \code{list(coef_index = 1)}. \code{nz} must be >= 5. The function is applied to \code{betabar_i[coef_index]}, others are 0.
\item For \code{"custom"}: \code{list(func = function(Zi) { ... })}. The function must take a vector \code{Zi} (a row of Z) and return a vector \code{betabar_i} of length \code{ncoef}.
}}

\item{ncomp}{Integer. Number of components in the normal mixture for residual heterogeneity (\code{eps_i}).}

\item{mixture_comps}{List. Optional pre-specified mixture components. A list of
length \code{ncomp}, where each element is \code{list(mu = ..., rooti = ...)}. \code{mu} is
the mean vector (length \code{ncoef}), \code{rooti} is the upper Cholesky factor of the
inverse covariance matrix (\verb{ncoef x ncoef}). If \code{NULL}, components are generated
based on \code{sigma_inv_diag}.}

\item{sigma_inv_diag}{Numeric. Diagonal value for the inverse covariance matrix
(precision) of mixture components if \code{mixture_comps} is \code{NULL}. Assumes identity
covariance scaled by this.}

\item{Xa_dist_func}{Function. Function to generate alternative-specific variables \code{Xa}.
Takes \code{n} (nT), \code{p}, \code{na} (nXa) and returns a matrix (usually \verb{n x (p*na)} or similar structure expected by \code{createX}).
Default: \code{function(n, p, na) matrix(runif(n*p*na, -1, 1), ncol=p*na)}.}

\item{Xd_dist_func}{Function. Function to generate choice-invariant variables \code{Xd}.
Takes \code{n} (nT), \code{nd} (nXd) and returns an \verb{n x nd} matrix.
Default: \code{function(n, nd) matrix(rnorm(n*nd), ncol=nd)}.}

\item{seed}{Integer. Optional random seed for reproducibility.}
}
\value{
A list suitable for direct use as the \code{Data} argument in
\code{rhierMnlRwMixture}, containing:
\itemize{
\item \code{p}: Number of alternatives.
\item \code{lgtdata}: List of length \code{nlgt}. Each element \code{i} is \code{list(y=y_i, X=X_i, beta=beta_i, betabar=betabar_i)}.
\item \code{Z}: The \verb{nlgt x nz} matrix of individual-specific covariates (standardized if requested).
Additionally, the list contains \code{true_values}:
\item \code{true_values$beta_true}: \verb{nlgt x ncoef} matrix of true \code{beta_i}.
\item \code{true_values$betabar_true}: \verb{nlgt x ncoef} matrix of true \code{betabar_i = f(Z_i)}.
\item \code{true_values$true_params}: List containing parameters used for generation (\code{beta_func_type}, \code{beta_func_args}, \code{mixture_comps}, \code{pvec}).
\item \code{true_values$dimensions}: List containing key dimensions used (\code{p}, \code{nlgt}, \code{nT}, \code{nz}, \code{ncoef}, etc.).
}
}
\description{
Generates simulated data suitable for testing hierarchical multinomial logit
models, particularly those involving individual-specific covariates (Z)
influencing coefficients (beta_i). Supports various functional forms for the
Z-beta relationship and mixture models for residual heterogeneity.
}
\examples{
# Simple linear example
sim_data_linear <- sim_hier_mnl(nlgt = 50, nT = 5, p = 3, nz = 2, nXa = 1, nXd = 0,
                               beta_func_type = "linear", seed = 123)
str(sim_data_linear)

# Step function example
sim_data_step <- sim_hier_mnl(nlgt = 50, nT = 5, p = 3, nz = 2, nXa = 1, nXd = 0,
                              beta_func_type = "step",
                              beta_func_args = list(Z_index = 1),
                              seed = 456)
str(sim_data_step$true_values$true_params) # Check args used
plot(sim_data_step$Z[,1], sim_data_step$true_values$betabar_true[,1]) # Visualize step

}
